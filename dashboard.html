	<!DOCTYPE html>
	<html lang="pt-BR">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Dashboard Aeroporto Imperatriz</title>
		<script src="https://unpkg.com/konva@9.3.0/konva.min.js"></script>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
		<script src="https://cdn.tailwindcss.com"></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
		<style>
			/* Estilos básicos para o corpo da página */
			body {
				font-family: 'Inter', sans-serif; /* Fonte Inter para uma aparência moderna */
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 20px;
				background-color: #f0f4f8; /* Cor de fundo suave */
				color: #333;
			}

			h1 {
				color: #2c3e50;
				margin-bottom: 25px;
				font-size: 2.2em;
				text-align: center;
			}

			/* Contêiner principal do dashboard */
			#dashboard-container {
				display: flex;
				flex-wrap: wrap; /* Permite que os itens se quebrem em telas menores */
				width: 95%;
				max-width: 1400px;
				background-color: #ffffff;
				border-radius: 12px; /* Cantos mais arredondados */
				box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1); /* Sombra mais pronunciada */
				padding: 25px;
				gap: 25px; /* Espaçamento entre as seções */
			}

			/* Contêiner para a área principal (canvas) */
			#main-content-area {
				flex: 3; /* Ocupa a maior parte do espaço */
				min-width: 600px;
			}

			/* Área do canvas (pista e ícones) */
			#canvas-area {
				position: relative;
				display: flex;
				flex-direction: column;
				gap: 20px;
				width: 100%;
			}

			/* Contêiner do Konva.js */
			#konva-container {
				border: 2px solid #dde1e6; /* Borda sutil */
				background-color: #e9eff4; /* Cor de fundo do canvas (simula o chão) */
				border-radius: 8px;
				overflow: hidden; /* Garante que nada saia da borda */
				box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05); /* Sombra interna */
				width: 100%;
				margin: 0;
				aspect-ratio: 2 / 1; /* Mantém a proporção 2:1 (largura/altura) */
				max-height: 700px;
				box-sizing: border-box; /* Garante que a borda seja incluída na largura de 100% */
			}

			/* Novo contêiner para os controles do METAR (HTML) */
			#metar-controls {
				display: flex;
				flex-direction: row; /* Alinha itens na linha */
				gap: 10px;
				margin-top: 1.5rem; /* Espaçamento do container acima */
				padding: 15px;
				background-color: #fcfdff;
				border: 2px solid #dde1e6;
				border-radius: 8px;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
				align-items: center; /* Centraliza verticalmente os itens */
				flex-wrap: wrap; /* Permite quebrar em linhas menores */
			}

			#metar-controls input {
				flex-grow: 1; /* Ocupa o máximo de espaço possível */
				min-width: 120px; /* Largura mínima para o input */
				padding: 8px 12px;
				border: 1px solid #ccc;
				border-radius: 6px;
				font-size: 1em;
				color: #333;
				box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
				outline: none; /* Remove o contorno padrão ao focar */
				transition: border-color 0.2s ease, box-shadow 0.2s ease;
			}

			#metar-controls input:focus {
				border-color: #3b82f6;
				box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
			}

			#metar-controls button {
				padding: 10px 15px;
				border-radius: 6px;
				font-weight: 600;
				cursor: pointer;
				transition: background-color 0.2s ease, transform 0.2s ease;
				box-shadow: 0 2px 5px rgba(0,0,0,0.1);
				color: white; /* Garante que o texto do botão seja branco */
				flex-shrink: 0; /* Não permite que os botões encolham */
			}
			
			#metar-controls button:hover {
				transform: translateY(-1px);
			}

			/* Estilos específicos para os botões do METAR */
			.metar-button-blue {
				background-color: #3b82f6; /* Blue-500 */
			}
			.metar-button-blue:hover {
				background-color: #2563eb; /* Blue-600 */
			}

			.metar-button-gray {
				background-color: #6b7280; /* Gray-500 */
			}
			.metar-button-gray:hover {
				background-color: #4b5563; /* Gray-600 */
			}

			/* Contêiner Konva para o display do METAR (apenas resultados) */
			#metar-display-konva-container {
				border: 2px solid #dde1e6;
				background-color: #fcfdff;
				border-radius: 8px;
				overflow: hidden;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
				width: 100%;
				min-height: 100px; /* Altura mínima para o container METAR */
				box-sizing: border-box;
				position: relative; /* Importante para posicionar elementos Konva */
			}

			/* Área de controles (agora apenas observações) */
			#controls-area {
				flex: 1; /* Ocupa o espaço restante */
				min-width: 300px; /* Largura mínima para os controles */
				display: flex;
				flex-direction: column;
				gap: 20px;
			}

			h2 {
				color: #34495e;
				font-size: 1.6em;
				border-bottom: 2px solid #e0e6ec;
				padding-bottom: 10px;
				margin-bottom: 15px;
			}

			/* Paleta de ícones (agora na área principal) */
			.icon-palette {
				display: flex;
				flex-wrap: wrap;
				justify-content: center; /* Centraliza os ícones */
				padding: 10px;
				border: 1px solid #dcdfe4;
				border-radius: 8px;
				background-color: #fcfdff;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
				width: 100%;
				box-sizing: border-box; /* Garante que o padding não quebre o layout */
			}

			.icon-palette .icon-item {
				width: 60px;
				height: 60px;
				cursor: pointer; /* Mudei para pointer para indicar que é clicável */
				margin: 8px;
				border-radius: 8px;
				transition: transform 0.2s ease, box-shadow 0.2s ease;
				padding: 5px;
				background-color: #f0f4f8;
				border: 1px solid #e0e6ec;
				display: flex;
				justify-content: center;
				align-items: center;
			}

			.icon-palette .icon-item img {
				max-width: 100%;
				max-height: 100%;
				object-fit: contain;
			}

			.icon-palette .icon-item:hover {
				transform: translateY(-3px) scale(1.05);
				box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
			}

			/* Área de observações (agora sozinha na #controls-area) */
			#observation-area {
				width: 100%;
			}

			#observation-area textarea {
				width: calc(100% - 22px); /* Ajusta para padding e borda */
				min-height: 150px;
				border: 1px solid #dcdfe4;
				border-radius: 8px;
				padding: 10px;
				resize: vertical;
				font-size: 1em;
				color: #333;
				background-color: #fcfdff;
				box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
			}

			#observation-area textarea::placeholder {
				color: #a0a0a0;
			}

			/* Contêiner para o Log de Eventos na parte inferior */
			#log-container {
				flex-basis: 100%;
			}

			/* Área do log de eventos */
			#log-area {
				border: 1px solid #dcdfe4;
				border-radius: 8px;
				padding: 15px;
				background-color: #fcfdff;
				height: 250px;
				overflow-y: auto;
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
			}

			#log-area ul {
				list-style: none;
				padding: 0;
				margin: 0;
			}

			#log-area li {
				padding: 8px 0;
				border-bottom: 1px dotted #e0e6ec;
				font-size: 0.95em;
				color: #555;
			}

			#log-area li:last-child {
				border-bottom: none;
			}

			/* Display do alarme (PISTA) */
			#alarm-display {
				width: 100%;
				height: 60px;
				background-color: #2ecc71;
				border-radius: 8px;
				display: flex;
				justify-content: center;
				align-items: center;
				color: white;
				font-weight: bold;
				font-size: 1.6em;
				transition: background-color 0.3s ease;
				box-shadow: 0 4px 10px rgba(46, 204, 113, 0.3);
				text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
			}

			#alarm-display.active {
				background-color: #e74c3c;
				animation: blink 1s infinite alternate;
				box-shadow: 0 4px 15px rgba(231, 76, 60, 0.5);
			}

			@keyframes blink {
				0% { opacity: 1; }
				50% { opacity: 0.7; }
				100% { opacity: 1; }
			}

			/* Mensagem de erro de carregamento da imagem */
			#image-load-error {
				color: #e74c3c;
				background-color: #fdeded;
				border: 1px solid #e74c3c;
				padding: 15px;
				border-radius: 8px;
				margin-top: 15px;
				font-weight: bold;
				text-align: center;
				display: none;
			}

			/* Estilos para Konva.Text do METAR (resultados, carregamento, erro, alarme) */
			.metar-text-result {
				/* Este é apenas um marcador. Os estilos reais vêm das propriedades Konva.Text */
			}
			.metar-loading-spinner-konva {
				/* Estilos para o spinner Konva (se implementado com Konva shapes/animations) */
			}

			/* Para o Alarme do METAR dentro do Konva */
			.metar-alarm-konva {
				animation: pulse 1.5s infinite alternate;
			}
			@keyframes pulse {
				0% { transform: scale(1); opacity: 1; }
				100% { transform: scale(1.02); opacity: 0.9; }
			}


			/* Responsividade */
			@media (max-width: 1024px) {
				#main-content-area, #controls-area {
					min-width: unset;
					width: 100%;
				}
				#konva-container {
					height: auto;
				}
			}

			@media (max-width: 768px) {
				h1 {
					font-size: 1.8em;
				}
				.icon-palette .icon-item {
					width: 50px;
					height: 50px;
				}
				#metar-controls {
					flex-direction: column;
					align-items: stretch; /* Estica os itens para preencher a largura */
				}
				#metar-controls button, #metar-controls input {
					width: 100%; /* Ocupa a largura total */
				}
			}
		</style>
	</head>
	<body>
		<h1>Monitoramento de Pista e METAR - Aeroporto de Imperatriz</h1>

		<div id="dashboard-container">
			
			<div id="main-content-area">
				<div id="canvas-area">
					<div id="alarm-display">Pista Livre</div>

					<div class="icon-palette">
						<div id="icon-cone" class="icon-item" data-icon-type="Pessoal Obra" data-image-url="cones.png">
							<img src="cones.png" alt="Cone">
						</div>
						<div id="icon-bombeiros" class="icon-item" data-icon-type="SCI" data-image-url="bombeiros.png">
							<img src="bombeiros.png" alt="bombeiros">
						</div>
						<div id="icon-airplane" class="icon-item" data-icon-type="Avião" data-image-url="aviao.png">
							<img src="aviao.png" alt="Avião">
						</div>
						<div id="icon-tools" class="icon-item" data-icon-type="Manutenção" data-image-url="ferramentas.png">
							<img src="ferramentas.png" alt="Ferramentas">
						</div>
						<div id="icon-vehicle" class="icon-item" data-icon-type="Viatura" data-image-url="viatura.png">
							<img src="viatura.png" alt="Viatura">
						</div>
						<div id="icon-person" class="icon-item" data-icon-type="Pessoa" data-image-url="pessoas.png">
							<img src="pessoas.png" alt="Pessoa">
						</div>
						<div id="icon-animals" class="icon-item" data-icon-type="Animais" data-image-url="animais.png">
							<img src="animais.png" alt="Animais">
						</div>
					</div>

					<div id="konva-container"></div>
					<div id="image-load-error" style="display: none;">
						Erro ao carregar a imagem da pista. Certifique-se de que o arquivo está na mesma pasta e que você está usando um servidor web local (ex: `python -m http.server`). Este erro também pode ser devido a uma política de segurança do navegador (CORS).
					</div>
				</div>
				<div id="metar-display-konva-container" class="mt-6"></div>
				<div id="metar-controls">
					<input
						type="text"
						id="icaoCodeInput"
						placeholder="Ex: SBIZ"
						value="SBIZ"
						class="metar-icao-input"
					/>
					<button id="fetchMetarButton" class="metar-button-blue">
						Buscar METAR/SPECI
					</button>
					<button id="downloadMetarLogButton" class="metar-button-gray">
						Download Log METAR
					</button>
				</div>

				

			</div>

			<div id="controls-area">
				<div id="observation-area">
					<h2>Observações</h2>
					<textarea id="observationsTextarea" placeholder="Escreva observações importantes aqui..."></textarea>
				</div>
			</div>

			<div id="log-container">
				<h2>Log de Eventos</h2>
				<div id="log-area">
					<ul>
						</ul>
				</div>
			</div>

		</div>

		<script>
			// --- CÓDIGO PISTA ---
			const konvaContainer = document.getElementById('konva-container');
			let width = konvaContainer.offsetWidth;
			let height = width * 0.5; // Proporção 2:1 (largura / altura)

			const stage = new Konva.Stage({
				container: 'konva-container',
				width: width,
				height: height,
			});

			const layer = new Konva.Layer();
			stage.add(layer);

			const logList = document.querySelector('#log-area ul');
			const alarmDisplay = document.getElementById('alarm-display');
			const imageLoadErrorDisplay = document.getElementById('image-load-error');

			let runwayPerimeter;

			const useImageRunway = true;
			const runwayImageUrl = 'minha_pista.jpeg'; // Caminho da imagem enviada pelo usuário (ATUALIZADO)

			function loadImage(url) {
				return new Promise((resolve, reject) => {
					const img = new Image();
					img.onload = () => {
						resolve(img);
					};
					img.onerror = (e) => {
						reject(e);
					};
					img.src = url;
				});
			}

			async function drawRunway() {
				imageLoadErrorDisplay.style.display = 'none';

				if (useImageRunway) {
					try {
						const imgElement = await loadImage(runwayImageUrl);
						const image = new Konva.Image({
							image: imgElement,
							x: 0,
							y: 0,
							width: stage.width(), // Usa stage.width() e height() para redimensionamento
							height: stage.height(),
						});
						layer.add(image);
						image.moveToBottom();

						// Ajuste estas coordenadas para SUA IMAGEM REAL DA PISTA
						runwayPerimeter = new Konva.Rect({
							x: stage.width() * 0.04,
							y: stage.height() * 0.24,
							width: stage.width() * 0.92,
							height: stage.height() * 0.23,
							fill: 'rgba(255, 0, 0, 0.25)', // Visível para depuração, pode ser alterado para 'rgba(0,0,0,0)'
							stroke: 'red',
							strokeWidth: 4,
							listening: false // Não interage com eventos do mouse
						});
						layer.add(runwayPerimeter);
						runwayPerimeter.moveToBottom();
						layer.batchDraw();
					} catch (error) {
						console.error("Erro ao carregar a imagem da pista:", error);
						imageLoadErrorDisplay.style.display = 'block';
						drawSimulatedRunwayContent();
					}
				} else {
					drawSimulatedRunwayContent();
				}
			}

			function drawSimulatedRunwayContent() {
				// Usa stage.width() e stage.height() para garantir o redimensionamento correto
				const currentWidth = stage.width();
				const currentHeight = stage.height();

				const grassLeft = new Konva.Rect({ x: 0, y: 0, width: currentWidth * 0.15, height: currentHeight, fill: '#8bc34a' });
				layer.add(grassLeft);
				const grassRight = new Konva.Rect({ x: currentWidth * 0.85, y: 0, width: currentWidth * 0.15, height: currentHeight, fill: '#8bc34a' });
				layer.add(grassRight);
				const grassTop = new Konva.Rect({ x: currentWidth * 0.15, y: 0, width: currentWidth * 0.7, height: currentHeight * 0.4, fill: '#8bc34a' });
				layer.add(grassTop);
				const grassBottom = new Konva.Rect({ x: currentWidth * 0.15, y: currentHeight * 0.6, width: currentWidth * 0.7, height: currentHeight * 0.4, fill: '#8bc34a' });
				layer.add(grassBottom);
				const runwayBody = new Konva.Rect({
					x: currentWidth * 0.15, y: currentHeight * 0.4, width: currentWidth * 0.7, height: currentHeight * 0.2,
					fill: '#000000', cornerRadius: 5,
				});
				layer.add(runwayBody);
				const centerline = new Konva.Line({
					points: [currentWidth * 0.15, currentHeight * 0.5, currentWidth * 0.85, currentHeight * 0.5],
					stroke: 'white', strokeWidth: 4, dash: [20, 15], lineCap: 'butt',
				});
				layer.add(centerline);
				const edgeLineTop = new Konva.Line({ points: [currentWidth * 0.15, currentHeight * 0.4, currentWidth * 0.85, currentHeight * 0.4], stroke: 'white', strokeWidth: 3 });
				layer.add(edgeLineTop);
				const edgeLineBottom = new Konva.Line({ points: [currentWidth * 0.15, currentHeight * 0.6, currentWidth * 0.85, currentHeight * 0.6], stroke: 'white', strokeWidth: 3 });
				layer.add(edgeLineBottom);
				const numThresholdLines = 10;
				const thresholdWidth = currentWidth * 0.05;
				const thresholdLineSpacing = thresholdWidth / (numThresholdLines + 1);
				for (let i = 0; i < numThresholdLines; i++) {
					const xPosLeft = currentWidth * 0.15 + thresholdLineSpacing * (i + 1);
					layer.add(new Konva.Line({ points: [xPosLeft, currentHeight * 0.4, xPosLeft, currentHeight * 0.6], stroke: 'white', strokeWidth: 6 }));
					const xPosRight = currentWidth * 0.85 - thresholdLineSpacing * (i + 1);
					layer.add(new Konva.Line({ points: [xPosRight, currentHeight * 0.4, xPosRight, currentHeight * 0.6], stroke: 'white', strokeWidth: 6 }));
				}
				const aimingPointWidth = currentWidth * 0.08;
				const aimingPointHeight = currentHeight * 0.1;
				const aimingPointOffset = currentWidth * 0.1;
				const aimingPointY = currentHeight * 0.5 - aimingPointHeight / 2;
				const aimingPointLeft = new Konva.Rect({ x: currentWidth * 0.15 + aimingPointOffset, y: aimingPointY, width: aimingPointWidth, height: aimingPointHeight, fill: 'white' });
				layer.add(aimingPointLeft);
				const aimingPointRight = new Konva.Rect({ x: currentWidth * 0.85 - aimingPointOffset - aimingPointWidth, y: aimingPointY, width: aimingPointWidth, height: aimingPointHeight, fill: 'white' });
				layer.add(aimingPointRight);
				const text07 = new Konva.Text({ x: currentWidth * 0.16, y: currentHeight * 0.49, text: '07', fontSize: 30, fontFamily: 'Arial', fill: 'white', rotation: -5, fontStyle: 'bold' });
				layer.add(text07);
				const text25 = new Konva.Text({ x: currentWidth * 0.81, y: currentHeight * 0.49, text: '25', fontSize: 30, fontFamily: 'Arial', fill: 'white', rotation: 5, fontStyle: 'bold' });
				layer.add(text25);
				runwayPerimeter = new Konva.Rect({
					x: currentWidth * 0.1, y: currentHeight * 0.35, width: currentWidth * 0.8, height: currentHeight * 0.3,
					fill: 'rgba(255, 0, 0, 0.25)', // Visível para depuração, pode ser alterado para 'rgba(0,0,0,0)'
					stroke: 'red',
					strokeWidth: 4,
					listening: false // Não interage com eventos do mouse
				});
				layer.add(runwayPerimeter);
				grassLeft.moveToBottom(); grassRight.moveToBottom(); grassTop.moveToBottom(); grassBottom.moveToBottom();
				runwayBody.moveToBottom(); centerline.moveToBottom(); edgeLineTop.moveToBottom(); edgeLineBottom.moveToBottom();
				aimingPointLeft.moveToBottom(); aimingPointRight.moveToBottom();
				text07.moveToBottom(); text25.moveToBottom();
				runwayPerimeter.moveToBottom();
				layer.batchDraw();
			}

			drawRunway();

			function addDraggableIcon(imageUrl, type) {
				loadImage(imageUrl).then(imgElement => {
					const image = new Konva.Image({
						image: imgElement,
						x: Math.random() * (stage.width() - 60), // Usa stage.width()
						y: Math.random() * (stage.height() - 60), // Usa stage.height()
						width: 50,
						height: 50,
						draggable: true,
						name: type,
						shadowColor: 'black',
						shadowBlur: 5,
						shadowOffset: { x: 3, y: 3 },
						shadowOpacity: 0.3,
						cornerRadius: 5,
					});

					layer.add(image);
					layer.batchDraw();

					image.on('dragend', function () {
						checkPerimeter(image);
					});
					image.on('dragmove', function () {
						checkPerimeter(image);
					});
				}).catch(error => {
					console.error(`Erro ao carregar imagem para o ícone ${type}:`, error);
				});
			}

			function checkPerimeter(icon) {
				if (!runwayPerimeter) {
					console.log("Perímetro da pista não definido ainda.");
					return;
				}

				const iconRect = {
					x: icon.x(),
					y: icon.y(),
					width: icon.width(),
					height: icon.height(),
				};

				const perimeterRect = {
					x: runwayPerimeter.x(),
					y: runwayPerimeter.y(),
					width: runwayPerimeter.width(),
					height: runwayPerimeter.height(),
				};

				const isInside = (iconRect.x < perimeterRect.x + perimeterRect.width &&
									iconRect.x + iconRect.width > perimeterRect.x &&
									iconRect.y < perimeterRect.y + perimeterRect.height &&
									iconRect.y + iconRect.height > perimeterRect.y);

				const iconType = icon.name();
				const currentTime = new Date().toLocaleString('pt-BR');

				if (typeof icon.isCurrentlyInside === 'undefined') {
					icon.isCurrentlyInside = false;
				}
				
				if (isInside && !icon.isCurrentlyInside) {
					addLogEntry(`${currentTime}: ${iconType} ENTROU na pista.`);
					icon.isCurrentlyInside = true;
					updateAlarmStatus();
				} else if (!isInside && icon.isCurrentlyInside) {
					addLogEntry(`${currentTime}: ${iconType} SAIU da pista.`);
					icon.isCurrentlyInside = false;
					updateAlarmStatus();
				}
			}

			function updateAlarmStatus() {
				let runwayOccupied = false;
				layer.find('Image').forEach(icon => {
					if (icon.isCurrentlyInside) {
						runwayOccupied = true;
						return false; // Sai do forEach mais cedo se encontrar um ícone
					}
				});

				if (runwayOccupied) {
					alarmDisplay.textContent = 'Pista Ocupada!';
					alarmDisplay.classList.add('active');
				} else {
					alarmDisplay.textContent = 'Pista Livre';
					alarmDisplay.classList.remove('active');
				}
			}

			function addLogEntry(message) {
				const listItem = document.createElement('li');
				listItem.textContent = message;
				logList.prepend(listItem);

				while (logList.children.length > 50) {
					logList.removeChild(logList.lastChild);
				}
			}

			document.querySelectorAll('.icon-palette .icon-item').forEach(item => {
				item.addEventListener('click', () => {
					const imageUrl = item.getAttribute('data-image-url');
					const iconType = item.getAttribute('data-icon-type');
					if (imageUrl && iconType) {
						addDraggableIcon(imageUrl, iconType);
						addLogEntry(`${new Date().toLocaleString('pt-BR')}: ${iconType} adicionado ao pátio.`);
					}
				});
			});

			// Lida com o redimensionamento da janela para a PISTA e METAR
			window.addEventListener('resize', () => {
				width = konvaContainer.offsetWidth;
				height = width * 0.5;
				stage.width(width);
				stage.height(height);

				layer.destroyChildren();
				drawRunway();
				layer.batchDraw();

				// Redimensiona o METAR Stage também
				resizeMetarDisplayKonva();
			});


			// --- CÓDIGO METAR INTEGRADO (com input HTML externo) ---
			const icaoCodeInput = document.getElementById('icaoCodeInput');
			const fetchMetarButton = document.getElementById('fetchMetarButton');
			const downloadMetarLogButton = document.getElementById('downloadMetarLogButton');
			const metarDisplayKonvaContainer = document.getElementById('metar-display-konva-container');

			let metarDisplayStage;
			let metarDisplayLayer;

			// Inicializa o estágio e a camada do METAR DISPLAY
			function initMetarDisplayKonva() {
				if (metarDisplayStage) {
					metarDisplayStage.destroy(); // Destrói o estágio existente se já houver um
				}
				metarDisplayStage = new Konva.Stage({
					container: 'metar-display-konva-container',
					width: metarDisplayKonvaContainer.offsetWidth,
					height: metarDisplayKonvaContainer.offsetHeight,
				});
				metarDisplayLayer = new Konva.Layer();
				metarDisplayStage.add(metarDisplayLayer);
				metarDisplayLayer.batchDraw();
			}

			initMetarDisplayKonva(); // Inicializa o Konva.js para o METAR DISPLAY na carga

			// Elementos visuais Konva para o DISPLAY do METAR
			let loadingTextMetar;
			let errorMessageTextMetar;
			let alarmMessageKonvaMetar;
			let resultsTextMetar;
			let initialPlaceholderTextMetar;
			let alarmRectMetar; // Retângulo para o alarme
			let alarmTextNodeMetar; // Texto para o alarme

			// Chave de API da REDEMET (Substitua pela sua chave real)
			const API_KEY = "ttMZrBTp4mD0xMkYAVxKMzyu7B9KL1nfCS6T1fMR"; // Mantenha sua chave aqui
			const BASE_URL = "https://api-redemet.decea.mil.br/mensagens/metar/";

			let pollingIntervalIdMetar;
			let currentPollingRateMetar = 30000; // Taxa de polling padrão (30 segundos)
			let lastFetchedHourMetar = -1; // Armazena a última hora UTC em que uma mensagem foi buscada com sucesso
			let isFastPollingMetar = false; // Flag para indicar se estamos no modo de polling rápido (10 segundos)
			let metarLogEntries = []; // Array para armazenar as entradas do log do METAR

			// Função para desenhar os componentes da UI do DISPLAY do METAR no Konva
			function drawMetarDisplayUI() {
				metarDisplayLayer.destroyChildren(); // Limpa a camada para redesenhar

				const padding = 15;
				const itemSpacing = 10;
				let currentY = padding;

				// Indicador de Carregamento
				loadingTextMetar = new Konva.Text({
					x: metarDisplayStage.width() / 2,
					y: metarDisplayStage.height() / 2 - 20, // Centraliza
					text: 'Carregando...',
					fontSize: 16,
					fontFamily: 'Inter',
					fill: '#666',
					align: 'center',
					verticalAlign: 'middle',
					visible: false,
				});
				loadingTextMetar.offsetX(loadingTextMetar.width() / 2); // Ajusta offset após definir texto
				metarDisplayLayer.add(loadingTextMetar);

				// Mensagem de Erro
				errorMessageTextMetar = new Konva.Text({
					x: metarDisplayStage.width() / 2,
					y: metarDisplayStage.height() / 2 - 30, // Um pouco acima do centro
					width: metarDisplayStage.width() - padding * 2, // Limita largura
					text: '',
					fontSize: 24,
					fontFamily: 'Inter',
					fill: '#ef4444',
					align: 'center',
					verticalAlign: 'middle',
					visible: false,
					wrap: 'word',
				});
				errorMessageTextMetar.offsetX(errorMessageTextMetar.width() / 2);
				metarDisplayLayer.add(errorMessageTextMetar);

				// Alarme Visual
				alarmRectMetar = new Konva.Rect({
					x: padding,
					y: padding, // Posição fixa no topo
					width: metarDisplayStage.width() - padding * 2,
					height: 50,
					fill: '#fefcbf',
					stroke: '#fcd34d',
					strokeWidth: 2,
					cornerRadius: 8,
					visible: false,
					listening: false, // Não precisa interagir
				});
				metarDisplayLayer.add(alarmRectMetar);

				alarmTextNodeMetar = new Konva.Text({
					x: alarmRectMetar.x() + alarmRectMetar.width() / 2,
					y: alarmRectMetar.y() + alarmRectMetar.height() / 2,
					text: 'ALERTA: Mensagem METAR/SPECI da hora atual não encontrada na rede!',
					fontSize: 16,
					fontFamily: 'Inter',
					fill: '#92400e',
					align: 'center',
					verticalAlign: 'middle',
					visible: false,
					wrap: 'word',
				});
				alarmTextNodeMetar.offsetX(alarmTextNodeMetar.width() / 2);
				alarmTextNodeMetar.offsetY(alarmTextNodeMetar.height() / 2);
				metarDisplayLayer.add(alarmTextNodeMetar);

				// Resultados do METAR
				initialPlaceholderTextMetar = new Konva.Text({
					x: metarDisplayStage.width() / 2,
					y: metarDisplayStage.height() / 2 - 20, // Centraliza
					text: 'Os resultados do METAR/SPECI aparecerão aqui.',
					fontSize: 14,
					fontFamily: 'Inter',
					fill: '#666',
					align: 'center',
					verticalAlign: 'middle',
				});
				initialPlaceholderTextMetar.offsetX(initialPlaceholderTextMetar.width() / 2);
				metarDisplayLayer.add(initialPlaceholderTextMetar);


				resultsTextMetar = new Konva.Text({
					x: padding,
					y: padding, // Começa do topo, abaixo do alarme se visível
					width: metarDisplayStage.width() - padding * 2,
					height: metarDisplayStage.height() - padding * 2, // Ocupa a altura restante
					text: '',
					fontSize: 24,
					fontFamily: 'monospace',
					fill: '#444',
					padding: 10,
					align: 'left',
					verticalAlign: 'top',
					wrap: 'word',
					lineHeight: 1.5,
					visible: false, // Inicialmente invisível
				});
				metarDisplayLayer.add(resultsTextMetar);

				metarDisplayLayer.batchDraw();
			}

			drawMetarDisplayUI(); // Desenha a UI do METAR DISPLAY na carga inicial

			function startPollingMetar(rate) {
				if (pollingIntervalIdMetar) {
					clearInterval(pollingIntervalIdMetar);
				}
				currentPollingRateMetar = rate;
				pollingIntervalIdMetar = setInterval(checkHourAndFetchMetar, currentPollingRateMetar);
				console.log(`METAR Polling iniciado com intervalo: ${currentPollingRateMetar / 1000} segundos`);
			}

			function hideMetarAlarm() {
				alarmRectMetar.visible(false);
				alarmTextNodeMetar.visible(false);
				metarDisplayLayer.batchDraw();
			}

			function showMetarAlarm() {
				alarmRectMetar.visible(true);
				alarmTextNodeMetar.visible(true);
				// Inicia ou reinicia a animação (se não estiver rodando)
				if (!alarmAnimation) {
					 alarmAnimation = new Konva.Tween({
						node: alarmRectMetar,
						duration: 0.75, // Metade do ciclo de pulso
						opacity: 0.7,
						easing: Konva.Easings.EaseInOut,
						yoyo: true, // Para pulsar para frente e para trás
						iterations: -1 // Loop infinito
					});
					alarmAnimation.play();
				}
				metarDisplayLayer.batchDraw();
			}

			let alarmAnimation = null; // Para controlar a animação do alarme

			function extractObservationHour(metarString) {
				const match = metarString.match(/\s\d{2}(\d{2})\d{2}Z/);
				if (match && match[1]) {
					return parseInt(match[1], 10);
				}
				return null;
			}

			function addMetarLogEntry(icaoCode, status, message = '') {
				const now = new Date();
				const timestamp = now.toISOString().replace('T', ' ').substring(0, 19) + 'Z';
				metarLogEntries.push(`[${timestamp}] ICAO: ${icaoCode} - Status: ${status} - Mensagem: ${message}`);
				// Adiciona também ao log geral do dashboard
				addLogEntry(`[METAR] ${timestamp}: ${icaoCode} - ${status} - ${message.split('\n')[0].substring(0, 50)}...`);
			}

			async function checkHourAndFetchMetar() {
				const currentHour = new Date().getUTCHours();

				// Lógica para o polling rápido quando a hora muda
				if (currentHour !== lastFetchedHourMetar && !isFastPollingMetar) {
					console.log(`METAR: Nova hora detectada (${currentHour}Z). Mudando para polling rápido.`);
					isFastPollingMetar = true;
					hideMetarAlarm();
					startPollingMetar(10000); // Mudar para 10 segundos
				}

				await fetchMetarSpeci();
			}

			async function fetchMetarSpeci() {
				const icaoCode = icaoCodeInput.value.trim().toUpperCase();

				// Mostrar indicadores de carregamento e limpar resultados/erros
				resultsTextMetar.text('');
				resultsTextMetar.visible(false);
				initialPlaceholderTextMetar.visible(true);
				errorMessageTextMetar.visible(false);
				loadingTextMetar.visible(true);
				metarDisplayLayer.batchDraw();
				
				hideMetarAlarm(); // Esconde o alarme no início de cada busca

				if (!icaoCode) {
					loadingTextMetar.visible(false);
					errorMessageTextMetar.text('Por favor, insira um código ICAO.');
					errorMessageTextMetar.visible(true);
					metarDisplayLayer.batchDraw();
					// Se não há ICAO, para o polling até que um seja inserido
					if (pollingIntervalIdMetar) clearInterval(pollingIntervalIdMetar); 
					addMetarLogEntry('N/A', 'ERRO', 'Código ICAO não inserido.');
					return;
				}

				const now = new Date();
				const oneHourAgo = new Date(now.getTime() - (60 * 60 * 1000)); // 1 hora atrás

				const formatDateTime = (date) => {
					const year = date.getUTCFullYear();
					const month = String(date.getUTCMonth() + 1).padStart(2, '0');
					const day = String(date.getUTCDate()).padStart(2, '0');
					const hours = String(date.getUTCHours()).padStart(2, '0');
					return `${year}${month}${day}${hours}`;
				};

				const data_ini = formatDateTime(oneHourAgo);
				const data_fim = formatDateTime(now);

				const url = `${BASE_URL}${icaoCode}?api_key=${API_KEY}&data_ini=${data_ini}&data_fim=${data_fim}`;

				try {
					const response = await fetch(url);
					
					if (!response.ok) {
						const errorData = await response.json().catch(() => ({}));
						let errorMsg = `Erro HTTP: ${response.status} ${response.statusText}.`;
						if (errorData.message) {
							errorMsg += ` Detalhes: ${errorData.message}`;
						} else if (response.status === 401) {
							errorMsg = 'Erro de autenticação: Verifique sua chave de API.';
						} else if (response.status === 404) {
							errorMsg = `Localidade "${icaoCode}" não encontrada ou sem dados recentes.`;
						}
						addMetarLogEntry(icaoCode, 'ERRO', errorMsg);
						throw new Error(errorMsg);
					}

					const data = await response.json();

					let messageFoundForCurrentHour = false;
					if (data.status && data.data && data.data.data && data.data.data.length > 0) {
						data.data.data.sort((a, b) => new Date(b.validade_inicial + 'Z').getTime() - new Date(a.validade_inicial + 'Z').getTime());

						const latestMessage = data.data.data[0];
						const observationHour = extractObservationHour(latestMessage.mens);
						const currentUTCHour = new Date().getUTCHours();

						if (observationHour !== null && observationHour === currentUTCHour) {
							messageFoundForCurrentHour = true;
							if (isFastPollingMetar) {
								console.log("METAR: Mensagem da hora atual encontrada durante o polling rápido. Voltando ao polling normal.");
								isFastPollingMetar = false;
								startPollingMetar(30000); // Voltar para 30 segundos
							}
							lastFetchedHourMetar = currentUTCHour; // Atualiza a última hora buscada com sucesso
							hideMetarAlarm();
							addMetarLogEntry(icaoCode, 'MENSAGEM ENCONTRADA', latestMessage.mens);
						} else {
							// Mensagem encontrada, mas não da hora atual (pode ser SPECI anterior ou METAR da hora passada)
							addMetarLogEntry(icaoCode, 'MENSAGEM ENCONTRADA (Hora Incorreta)', latestMessage.mens);
						}

						let resultString = '';
						data.data.data.forEach(item => {
							//resultString += `Localidade: ${item.id_localidade}\n`;
							//resultString += `Validade Inicial: ${item.validade_inicial}\n`;
							resultString += `Mensagem: ${item.mens}\n`;
							resultString += `Recebimento: ${item.recebimento}\n\n`;
						});
						resultsTextMetar.text(resultString);
						resultsTextMetar.visible(true);
						initialPlaceholderTextMetar.visible(false);

					} else {
						resultsTextMetar.text(`Nenhum dado METAR/SPECI recente encontrado para "${icaoCode}".`);
						resultsTextMetar.visible(true);
						initialPlaceholderTextMetar.visible(false);
						addMetarLogEntry(icaoCode, 'MENSAGEM NÃO ENCONTRADA', 'Nenhum dado recente retornado pela API.');
					}

					// Lógica do alarme: se estamos em fast polling e não encontramos a mensagem da hora atual
					if (isFastPollingMetar && !messageFoundForCurrentHour) {
						showMetarAlarm();
					} else {
						hideMetarAlarm();
					}

				} catch (error) {
					errorMessageTextMetar.text(`Erro ao buscar dados: ${error.message}`);
					errorMessageTextMetar.visible(true);
					resultsTextMetar.visible(false);
					initialPlaceholderTextMetar.visible(true); // Mostra o placeholder novamente em caso de erro
					
					// Se houver erro durante o polling rápido, e não encontrou, mostra o alarme
					if (isFastPollingMetar) {
						showMetarAlarm();
					} else {
						hideMetarAlarm();
					}
				} finally {
					loadingTextMetar.visible(false);
					metarDisplayLayer.batchDraw();
				}
			}

			function downloadMetarLog() {
				if (metarLogEntries.length === 0) {
					alert('Nenhum log METAR para baixar.');
					return;
				}

				const logContent = metarLogEntries.join('\n');
				const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
				const now = new Date();
				const filename = `metar_log_${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}.txt`;

				const a = document.createElement('a');
				a.href = URL.createObjectURL(blob);
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(a.href);
			}

			// Função para redimensionar o estágio do DISPLAY METAR
			function resizeMetarDisplayKonva() {
				metarDisplayStage.width(metarDisplayKonvaContainer.offsetWidth);
				metarDisplayStage.height(metarDisplayKonvaContainer.offsetHeight);
				drawMetarDisplayUI(); // Redesenha a UI para ajustar os elementos Konva
				metarDisplayLayer.batchDraw();
			}

			// Event listeners para os botões e input do METAR
			fetchMetarButton.addEventListener('click', () => {
				isFastPollingMetar = false; // O clique manual reseta o estado de polling rápido
				startPollingMetar(30000); // Inicia o polling normal
				fetchMetarSpeci(); // Realiza uma busca imediata
			});

			icaoCodeInput.addEventListener('keypress', (event) => {
				if (event.key === 'Enter') {
					isFastPollingMetar = false; // O input manual reseta o estado de polling rápido
					startPollingMetar(30000); // Inicia o polling normal
					fetchMetarSpeci(); // Realiza uma busca imediata
				}
			});

			downloadMetarLogButton.addEventListener('click', downloadMetarLog);

			// Configuração inicial do METAR: Realiza uma busca e então inicia o polling normal
			icaoCodeInput.value = 'SBIZ'; // Define um valor padrão para Imperatriz
			fetchMetarSpeci().then(() => {
				startPollingMetar(30000); // Inicia o polling normal após a busca inicial
			});

		</script>
	</body>
	</html>